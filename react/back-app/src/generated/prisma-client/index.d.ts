// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  author: (where?: AuthorWhereInput) => Promise<boolean>;
  content: (where?: ContentWhereInput) => Promise<boolean>;
  direction: (where?: DirectionWhereInput) => Promise<boolean>;
  profession: (where?: ProfessionWhereInput) => Promise<boolean>;
  resource: (where?: ResourceWhereInput) => Promise<boolean>;
  specialization: (where?: SpecializationWhereInput) => Promise<boolean>;
  title: (where?: TitleWhereInput) => Promise<boolean>;
  udc: (where?: UdcWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  author: (where: AuthorWhereUniqueInput) => AuthorNullablePromise;
  authors: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Author>;
  authorsConnection: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthorConnectionPromise;
  content: (where: ContentWhereUniqueInput) => ContentNullablePromise;
  contents: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Content>;
  contentsConnection: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContentConnectionPromise;
  direction: (where: DirectionWhereUniqueInput) => DirectionNullablePromise;
  directions: (args?: {
    where?: DirectionWhereInput;
    orderBy?: DirectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Direction>;
  directionsConnection: (args?: {
    where?: DirectionWhereInput;
    orderBy?: DirectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DirectionConnectionPromise;
  profession: (where: ProfessionWhereUniqueInput) => ProfessionNullablePromise;
  professions: (args?: {
    where?: ProfessionWhereInput;
    orderBy?: ProfessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Profession>;
  professionsConnection: (args?: {
    where?: ProfessionWhereInput;
    orderBy?: ProfessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProfessionConnectionPromise;
  resource: (where: ResourceWhereUniqueInput) => ResourceNullablePromise;
  resources: (args?: {
    where?: ResourceWhereInput;
    orderBy?: ResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Resource>;
  resourcesConnection: (args?: {
    where?: ResourceWhereInput;
    orderBy?: ResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ResourceConnectionPromise;
  specialization: (
    where: SpecializationWhereUniqueInput
  ) => SpecializationNullablePromise;
  specializations: (args?: {
    where?: SpecializationWhereInput;
    orderBy?: SpecializationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Specialization>;
  specializationsConnection: (args?: {
    where?: SpecializationWhereInput;
    orderBy?: SpecializationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpecializationConnectionPromise;
  title: (where: TitleWhereUniqueInput) => TitleNullablePromise;
  titles: (args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Title>;
  titlesConnection: (args?: {
    where?: TitleWhereInput;
    orderBy?: TitleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TitleConnectionPromise;
  udc: (where: UdcWhereUniqueInput) => UdcNullablePromise;
  udcs: (args?: {
    where?: UdcWhereInput;
    orderBy?: UdcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Udc>;
  udcsConnection: (args?: {
    where?: UdcWhereInput;
    orderBy?: UdcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UdcConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuthor: (data: AuthorCreateInput) => AuthorPromise;
  updateAuthor: (args: {
    data: AuthorUpdateInput;
    where: AuthorWhereUniqueInput;
  }) => AuthorPromise;
  updateManyAuthors: (args: {
    data: AuthorUpdateManyMutationInput;
    where?: AuthorWhereInput;
  }) => BatchPayloadPromise;
  upsertAuthor: (args: {
    where: AuthorWhereUniqueInput;
    create: AuthorCreateInput;
    update: AuthorUpdateInput;
  }) => AuthorPromise;
  deleteAuthor: (where: AuthorWhereUniqueInput) => AuthorPromise;
  deleteManyAuthors: (where?: AuthorWhereInput) => BatchPayloadPromise;
  createContent: (data: ContentCreateInput) => ContentPromise;
  updateContent: (args: {
    data: ContentUpdateInput;
    where: ContentWhereUniqueInput;
  }) => ContentPromise;
  updateManyContents: (args: {
    data: ContentUpdateManyMutationInput;
    where?: ContentWhereInput;
  }) => BatchPayloadPromise;
  upsertContent: (args: {
    where: ContentWhereUniqueInput;
    create: ContentCreateInput;
    update: ContentUpdateInput;
  }) => ContentPromise;
  deleteContent: (where: ContentWhereUniqueInput) => ContentPromise;
  deleteManyContents: (where?: ContentWhereInput) => BatchPayloadPromise;
  createDirection: (data: DirectionCreateInput) => DirectionPromise;
  updateDirection: (args: {
    data: DirectionUpdateInput;
    where: DirectionWhereUniqueInput;
  }) => DirectionPromise;
  updateManyDirections: (args: {
    data: DirectionUpdateManyMutationInput;
    where?: DirectionWhereInput;
  }) => BatchPayloadPromise;
  upsertDirection: (args: {
    where: DirectionWhereUniqueInput;
    create: DirectionCreateInput;
    update: DirectionUpdateInput;
  }) => DirectionPromise;
  deleteDirection: (where: DirectionWhereUniqueInput) => DirectionPromise;
  deleteManyDirections: (where?: DirectionWhereInput) => BatchPayloadPromise;
  createProfession: (data: ProfessionCreateInput) => ProfessionPromise;
  updateProfession: (args: {
    data: ProfessionUpdateInput;
    where: ProfessionWhereUniqueInput;
  }) => ProfessionPromise;
  updateManyProfessions: (args: {
    data: ProfessionUpdateManyMutationInput;
    where?: ProfessionWhereInput;
  }) => BatchPayloadPromise;
  upsertProfession: (args: {
    where: ProfessionWhereUniqueInput;
    create: ProfessionCreateInput;
    update: ProfessionUpdateInput;
  }) => ProfessionPromise;
  deleteProfession: (where: ProfessionWhereUniqueInput) => ProfessionPromise;
  deleteManyProfessions: (where?: ProfessionWhereInput) => BatchPayloadPromise;
  createResource: (data: ResourceCreateInput) => ResourcePromise;
  updateResource: (args: {
    data: ResourceUpdateInput;
    where: ResourceWhereUniqueInput;
  }) => ResourcePromise;
  upsertResource: (args: {
    where: ResourceWhereUniqueInput;
    create: ResourceCreateInput;
    update: ResourceUpdateInput;
  }) => ResourcePromise;
  deleteResource: (where: ResourceWhereUniqueInput) => ResourcePromise;
  deleteManyResources: (where?: ResourceWhereInput) => BatchPayloadPromise;
  createSpecialization: (
    data: SpecializationCreateInput
  ) => SpecializationPromise;
  updateSpecialization: (args: {
    data: SpecializationUpdateInput;
    where: SpecializationWhereUniqueInput;
  }) => SpecializationPromise;
  updateManySpecializations: (args: {
    data: SpecializationUpdateManyMutationInput;
    where?: SpecializationWhereInput;
  }) => BatchPayloadPromise;
  upsertSpecialization: (args: {
    where: SpecializationWhereUniqueInput;
    create: SpecializationCreateInput;
    update: SpecializationUpdateInput;
  }) => SpecializationPromise;
  deleteSpecialization: (
    where: SpecializationWhereUniqueInput
  ) => SpecializationPromise;
  deleteManySpecializations: (
    where?: SpecializationWhereInput
  ) => BatchPayloadPromise;
  createTitle: (data: TitleCreateInput) => TitlePromise;
  updateTitle: (args: {
    data: TitleUpdateInput;
    where: TitleWhereUniqueInput;
  }) => TitlePromise;
  updateManyTitles: (args: {
    data: TitleUpdateManyMutationInput;
    where?: TitleWhereInput;
  }) => BatchPayloadPromise;
  upsertTitle: (args: {
    where: TitleWhereUniqueInput;
    create: TitleCreateInput;
    update: TitleUpdateInput;
  }) => TitlePromise;
  deleteTitle: (where: TitleWhereUniqueInput) => TitlePromise;
  deleteManyTitles: (where?: TitleWhereInput) => BatchPayloadPromise;
  createUdc: (data: UdcCreateInput) => UdcPromise;
  updateUdc: (args: {
    data: UdcUpdateInput;
    where: UdcWhereUniqueInput;
  }) => UdcPromise;
  updateManyUdcs: (args: {
    data: UdcUpdateManyMutationInput;
    where?: UdcWhereInput;
  }) => BatchPayloadPromise;
  upsertUdc: (args: {
    where: UdcWhereUniqueInput;
    create: UdcCreateInput;
    update: UdcUpdateInput;
  }) => UdcPromise;
  deleteUdc: (where: UdcWhereUniqueInput) => UdcPromise;
  deleteManyUdcs: (where?: UdcWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  author: (
    where?: AuthorSubscriptionWhereInput
  ) => AuthorSubscriptionPayloadSubscription;
  content: (
    where?: ContentSubscriptionWhereInput
  ) => ContentSubscriptionPayloadSubscription;
  direction: (
    where?: DirectionSubscriptionWhereInput
  ) => DirectionSubscriptionPayloadSubscription;
  profession: (
    where?: ProfessionSubscriptionWhereInput
  ) => ProfessionSubscriptionPayloadSubscription;
  resource: (
    where?: ResourceSubscriptionWhereInput
  ) => ResourceSubscriptionPayloadSubscription;
  specialization: (
    where?: SpecializationSubscriptionWhereInput
  ) => SpecializationSubscriptionPayloadSubscription;
  title: (
    where?: TitleSubscriptionWhereInput
  ) => TitleSubscriptionPayloadSubscription;
  udc: (
    where?: UdcSubscriptionWhereInput
  ) => UdcSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC";

export type DirectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC";

export type ProfessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "profession_ASC"
  | "profession_DESC";

export type ResourceOrderByInput = "id_ASC" | "id_DESC";

export type SpecializationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "specialization_ASC"
  | "specialization_DESC";

export type AuthorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fullName_ASC"
  | "fullName_DESC";

export type TitleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC";

export type UdcOrderByInput = "id_ASC" | "id_DESC" | "udc_ASC" | "udc_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface DirectionUpdateManyMutationInput {
  code?: Maybe<String>;
}

export type AuthorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TitleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AuthorUpdateWithWhereUniqueNestedInput {
  where: AuthorWhereUniqueInput;
  data: AuthorUpdateDataInput;
}

export interface AuthorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullName?: Maybe<String>;
  fullName_not?: Maybe<String>;
  fullName_in?: Maybe<String[] | String>;
  fullName_not_in?: Maybe<String[] | String>;
  fullName_lt?: Maybe<String>;
  fullName_lte?: Maybe<String>;
  fullName_gt?: Maybe<String>;
  fullName_gte?: Maybe<String>;
  fullName_contains?: Maybe<String>;
  fullName_not_contains?: Maybe<String>;
  fullName_starts_with?: Maybe<String>;
  fullName_not_starts_with?: Maybe<String>;
  fullName_ends_with?: Maybe<String>;
  fullName_not_ends_with?: Maybe<String>;
  AND?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  OR?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  NOT?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
}

export interface AuthorCreateManyInput {
  create?: Maybe<AuthorCreateInput[] | AuthorCreateInput>;
  connect?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
}

export interface DirectionUpdateDataInput {
  code?: Maybe<String>;
}

export interface ContentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContentWhereInput[] | ContentWhereInput>;
  OR?: Maybe<ContentWhereInput[] | ContentWhereInput>;
  NOT?: Maybe<ContentWhereInput[] | ContentWhereInput>;
}

export interface DirectionUpdateOneInput {
  create?: Maybe<DirectionCreateInput>;
  update?: Maybe<DirectionUpdateDataInput>;
  upsert?: Maybe<DirectionUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DirectionWhereUniqueInput>;
}

export interface SpecializationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpecializationWhereInput>;
  AND?: Maybe<
    | SpecializationSubscriptionWhereInput[]
    | SpecializationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SpecializationSubscriptionWhereInput[]
    | SpecializationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SpecializationSubscriptionWhereInput[]
    | SpecializationSubscriptionWhereInput
  >;
}

export interface TitleUpsertNestedInput {
  update: TitleUpdateDataInput;
  create: TitleCreateInput;
}

export interface ProfessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProfessionWhereInput>;
  AND?: Maybe<
    ProfessionSubscriptionWhereInput[] | ProfessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProfessionSubscriptionWhereInput[] | ProfessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProfessionSubscriptionWhereInput[] | ProfessionSubscriptionWhereInput
  >;
}

export type UdcWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DirectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DirectionWhereInput>;
  AND?: Maybe<
    DirectionSubscriptionWhereInput[] | DirectionSubscriptionWhereInput
  >;
  OR?: Maybe<
    DirectionSubscriptionWhereInput[] | DirectionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DirectionSubscriptionWhereInput[] | DirectionSubscriptionWhereInput
  >;
}

export interface TitleUpdateDataInput {
  title?: Maybe<String>;
}

export interface ContentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContentWhereInput>;
  AND?: Maybe<ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput>;
  OR?: Maybe<ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput>;
  NOT?: Maybe<ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput>;
}

export interface TitleUpdateOneInput {
  create?: Maybe<TitleCreateInput>;
  update?: Maybe<TitleUpdateDataInput>;
  upsert?: Maybe<TitleUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TitleWhereUniqueInput>;
}

export interface UdcUpdateManyMutationInput {
  udc?: Maybe<String>;
}

export interface AuthorUpdateManyDataInput {
  fullName?: Maybe<String>;
}

export type ProfessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AuthorUpdateManyWithWhereNestedInput {
  where: AuthorScalarWhereInput;
  data: AuthorUpdateManyDataInput;
}

export interface ProfessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  profession?: Maybe<String>;
  profession_not?: Maybe<String>;
  profession_in?: Maybe<String[] | String>;
  profession_not_in?: Maybe<String[] | String>;
  profession_lt?: Maybe<String>;
  profession_lte?: Maybe<String>;
  profession_gt?: Maybe<String>;
  profession_gte?: Maybe<String>;
  profession_contains?: Maybe<String>;
  profession_not_contains?: Maybe<String>;
  profession_starts_with?: Maybe<String>;
  profession_not_starts_with?: Maybe<String>;
  profession_ends_with?: Maybe<String>;
  profession_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProfessionWhereInput[] | ProfessionWhereInput>;
  OR?: Maybe<ProfessionWhereInput[] | ProfessionWhereInput>;
  NOT?: Maybe<ProfessionWhereInput[] | ProfessionWhereInput>;
}

export interface SpecializationUpdateManyMutationInput {
  specialization?: Maybe<String>;
}

export interface ContentUpsertNestedInput {
  update: ContentUpdateDataInput;
  create: ContentCreateInput;
}

export interface AuthorCreateInput {
  id?: Maybe<ID_Input>;
  fullName: String;
}

export interface ContentUpdateDataInput {
  content?: Maybe<String>;
}

export interface AuthorUpdateInput {
  fullName?: Maybe<String>;
}

export interface UdcUpsertNestedInput {
  update: UdcUpdateDataInput;
  create: UdcCreateInput;
}

export interface AuthorUpdateManyMutationInput {
  fullName?: Maybe<String>;
}

export interface ResourceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  author_every?: Maybe<AuthorWhereInput>;
  author_some?: Maybe<AuthorWhereInput>;
  author_none?: Maybe<AuthorWhereInput>;
  subAuthor_every?: Maybe<AuthorWhereInput>;
  subAuthor_some?: Maybe<AuthorWhereInput>;
  subAuthor_none?: Maybe<AuthorWhereInput>;
  title?: Maybe<TitleWhereInput>;
  direction?: Maybe<DirectionWhereInput>;
  profession?: Maybe<ProfessionWhereInput>;
  specialization?: Maybe<SpecializationWhereInput>;
  udc?: Maybe<UdcWhereInput>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<ResourceWhereInput[] | ResourceWhereInput>;
  OR?: Maybe<ResourceWhereInput[] | ResourceWhereInput>;
  NOT?: Maybe<ResourceWhereInput[] | ResourceWhereInput>;
}

export interface AuthorScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullName?: Maybe<String>;
  fullName_not?: Maybe<String>;
  fullName_in?: Maybe<String[] | String>;
  fullName_not_in?: Maybe<String[] | String>;
  fullName_lt?: Maybe<String>;
  fullName_lte?: Maybe<String>;
  fullName_gt?: Maybe<String>;
  fullName_gte?: Maybe<String>;
  fullName_contains?: Maybe<String>;
  fullName_not_contains?: Maybe<String>;
  fullName_starts_with?: Maybe<String>;
  fullName_not_starts_with?: Maybe<String>;
  fullName_ends_with?: Maybe<String>;
  fullName_not_ends_with?: Maybe<String>;
  AND?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
  OR?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
  NOT?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
}

export interface SpecializationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  specialization?: Maybe<String>;
  specialization_not?: Maybe<String>;
  specialization_in?: Maybe<String[] | String>;
  specialization_not_in?: Maybe<String[] | String>;
  specialization_lt?: Maybe<String>;
  specialization_lte?: Maybe<String>;
  specialization_gt?: Maybe<String>;
  specialization_gte?: Maybe<String>;
  specialization_contains?: Maybe<String>;
  specialization_not_contains?: Maybe<String>;
  specialization_starts_with?: Maybe<String>;
  specialization_not_starts_with?: Maybe<String>;
  specialization_ends_with?: Maybe<String>;
  specialization_not_ends_with?: Maybe<String>;
  AND?: Maybe<SpecializationWhereInput[] | SpecializationWhereInput>;
  OR?: Maybe<SpecializationWhereInput[] | SpecializationWhereInput>;
  NOT?: Maybe<SpecializationWhereInput[] | SpecializationWhereInput>;
}

export interface AuthorUpsertWithWhereUniqueNestedInput {
  where: AuthorWhereUniqueInput;
  update: AuthorUpdateDataInput;
  create: AuthorCreateInput;
}

export interface UdcUpdateOneInput {
  create?: Maybe<UdcCreateInput>;
  update?: Maybe<UdcUpdateDataInput>;
  upsert?: Maybe<UdcUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UdcWhereUniqueInput>;
}

export interface ContentCreateInput {
  id?: Maybe<ID_Input>;
  content: String;
}

export interface SpecializationUpdateDataInput {
  specialization?: Maybe<String>;
}

export interface ContentUpdateInput {
  content?: Maybe<String>;
}

export type SpecializationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContentUpdateManyMutationInput {
  content?: Maybe<String>;
}

export interface ProfessionUpdateDataInput {
  profession?: Maybe<String>;
}

export interface DirectionCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
}

export interface DirectionUpsertNestedInput {
  update: DirectionUpdateDataInput;
  create: DirectionCreateInput;
}

export interface DirectionUpdateInput {
  code?: Maybe<String>;
}

export interface TitleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TitleWhereInput>;
  AND?: Maybe<TitleSubscriptionWhereInput[] | TitleSubscriptionWhereInput>;
  OR?: Maybe<TitleSubscriptionWhereInput[] | TitleSubscriptionWhereInput>;
  NOT?: Maybe<TitleSubscriptionWhereInput[] | TitleSubscriptionWhereInput>;
}

export interface AuthorUpdateDataInput {
  fullName?: Maybe<String>;
}

export type DirectionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProfessionCreateInput {
  id?: Maybe<ID_Input>;
  profession: String;
}

export interface AuthorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthorWhereInput>;
  AND?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  OR?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  NOT?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
}

export interface ProfessionUpdateInput {
  profession?: Maybe<String>;
}

export interface TitleUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface ProfessionUpdateManyMutationInput {
  profession?: Maybe<String>;
}

export interface SpecializationUpdateInput {
  specialization?: Maybe<String>;
}

export interface ResourceCreateInput {
  id?: Maybe<ID_Input>;
  author?: Maybe<AuthorCreateManyInput>;
  subAuthor?: Maybe<AuthorCreateManyInput>;
  title?: Maybe<TitleCreateOneInput>;
  direction?: Maybe<DirectionCreateOneInput>;
  profession?: Maybe<ProfessionCreateOneInput>;
  specialization?: Maybe<SpecializationCreateOneInput>;
  udc?: Maybe<UdcCreateOneInput>;
  content?: Maybe<ContentCreateOneInput>;
}

export interface ContentUpdateOneInput {
  create?: Maybe<ContentCreateInput>;
  update?: Maybe<ContentUpdateDataInput>;
  upsert?: Maybe<ContentUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export type ContentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TitleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<TitleWhereInput[] | TitleWhereInput>;
  OR?: Maybe<TitleWhereInput[] | TitleWhereInput>;
  NOT?: Maybe<TitleWhereInput[] | TitleWhereInput>;
}

export interface TitleCreateOneInput {
  create?: Maybe<TitleCreateInput>;
  connect?: Maybe<TitleWhereUniqueInput>;
}

export interface SpecializationUpsertNestedInput {
  update: SpecializationUpdateDataInput;
  create: SpecializationCreateInput;
}

export interface TitleCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
}

export interface ProfessionUpsertNestedInput {
  update: ProfessionUpdateDataInput;
  create: ProfessionCreateInput;
}

export interface DirectionCreateOneInput {
  create?: Maybe<DirectionCreateInput>;
  connect?: Maybe<DirectionWhereUniqueInput>;
}

export interface UdcSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UdcWhereInput>;
  AND?: Maybe<UdcSubscriptionWhereInput[] | UdcSubscriptionWhereInput>;
  OR?: Maybe<UdcSubscriptionWhereInput[] | UdcSubscriptionWhereInput>;
  NOT?: Maybe<UdcSubscriptionWhereInput[] | UdcSubscriptionWhereInput>;
}

export interface ProfessionCreateOneInput {
  create?: Maybe<ProfessionCreateInput>;
  connect?: Maybe<ProfessionWhereUniqueInput>;
}

export interface DirectionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  AND?: Maybe<DirectionWhereInput[] | DirectionWhereInput>;
  OR?: Maybe<DirectionWhereInput[] | DirectionWhereInput>;
  NOT?: Maybe<DirectionWhereInput[] | DirectionWhereInput>;
}

export interface SpecializationCreateOneInput {
  create?: Maybe<SpecializationCreateInput>;
  connect?: Maybe<SpecializationWhereUniqueInput>;
}

export interface TitleUpdateInput {
  title?: Maybe<String>;
}

export interface SpecializationCreateInput {
  id?: Maybe<ID_Input>;
  specialization: String;
}

export interface UdcUpdateDataInput {
  udc?: Maybe<String>;
}

export interface UdcCreateOneInput {
  create?: Maybe<UdcCreateInput>;
  connect?: Maybe<UdcWhereUniqueInput>;
}

export interface SpecializationUpdateOneInput {
  create?: Maybe<SpecializationCreateInput>;
  update?: Maybe<SpecializationUpdateDataInput>;
  upsert?: Maybe<SpecializationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SpecializationWhereUniqueInput>;
}

export interface AuthorUpdateManyInput {
  create?: Maybe<AuthorCreateInput[] | AuthorCreateInput>;
  update?: Maybe<
    | AuthorUpdateWithWhereUniqueNestedInput[]
    | AuthorUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | AuthorUpsertWithWhereUniqueNestedInput[]
    | AuthorUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  connect?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  set?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  disconnect?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  deleteMany?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
  updateMany?: Maybe<
    | AuthorUpdateManyWithWhereNestedInput[]
    | AuthorUpdateManyWithWhereNestedInput
  >;
}

export interface ResourceUpdateInput {
  author?: Maybe<AuthorUpdateManyInput>;
  subAuthor?: Maybe<AuthorUpdateManyInput>;
  title?: Maybe<TitleUpdateOneInput>;
  direction?: Maybe<DirectionUpdateOneInput>;
  profession?: Maybe<ProfessionUpdateOneInput>;
  specialization?: Maybe<SpecializationUpdateOneInput>;
  udc?: Maybe<UdcUpdateOneInput>;
  content?: Maybe<ContentUpdateOneInput>;
}

export interface ContentCreateOneInput {
  create?: Maybe<ContentCreateInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface UdcCreateInput {
  id?: Maybe<ID_Input>;
  udc: String;
}

export interface ProfessionUpdateOneInput {
  create?: Maybe<ProfessionCreateInput>;
  update?: Maybe<ProfessionUpdateDataInput>;
  upsert?: Maybe<ProfessionUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProfessionWhereUniqueInput>;
}

export interface UdcWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  udc?: Maybe<String>;
  udc_not?: Maybe<String>;
  udc_in?: Maybe<String[] | String>;
  udc_not_in?: Maybe<String[] | String>;
  udc_lt?: Maybe<String>;
  udc_lte?: Maybe<String>;
  udc_gt?: Maybe<String>;
  udc_gte?: Maybe<String>;
  udc_contains?: Maybe<String>;
  udc_not_contains?: Maybe<String>;
  udc_starts_with?: Maybe<String>;
  udc_not_starts_with?: Maybe<String>;
  udc_ends_with?: Maybe<String>;
  udc_not_ends_with?: Maybe<String>;
  AND?: Maybe<UdcWhereInput[] | UdcWhereInput>;
  OR?: Maybe<UdcWhereInput[] | UdcWhereInput>;
  NOT?: Maybe<UdcWhereInput[] | UdcWhereInput>;
}

export type ResourceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UdcUpdateInput {
  udc?: Maybe<String>;
}

export interface ResourceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ResourceWhereInput>;
  AND?: Maybe<
    ResourceSubscriptionWhereInput[] | ResourceSubscriptionWhereInput
  >;
  OR?: Maybe<ResourceSubscriptionWhereInput[] | ResourceSubscriptionWhereInput>;
  NOT?: Maybe<
    ResourceSubscriptionWhereInput[] | ResourceSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UdcPreviousValues {
  id: ID_Output;
  udc: String;
}

export interface UdcPreviousValuesPromise
  extends Promise<UdcPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  udc: () => Promise<String>;
}

export interface UdcPreviousValuesSubscription
  extends Promise<AsyncIterator<UdcPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  udc: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDirection {
  count: Int;
}

export interface AggregateDirectionPromise
  extends Promise<AggregateDirection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDirectionSubscription
  extends Promise<AsyncIterator<AggregateDirection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAuthor {
  count: Int;
}

export interface AggregateAuthorPromise
  extends Promise<AggregateAuthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthorSubscription
  extends Promise<AsyncIterator<AggregateAuthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DirectionEdge {
  node: Direction;
  cursor: String;
}

export interface DirectionEdgePromise
  extends Promise<DirectionEdge>,
    Fragmentable {
  node: <T = DirectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DirectionEdgeSubscription
  extends Promise<AsyncIterator<DirectionEdge>>,
    Fragmentable {
  node: <T = DirectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DirectionConnection {
  pageInfo: PageInfo;
  edges: DirectionEdge[];
}

export interface DirectionConnectionPromise
  extends Promise<DirectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DirectionEdge>>() => T;
  aggregate: <T = AggregateDirectionPromise>() => T;
}

export interface DirectionConnectionSubscription
  extends Promise<AsyncIterator<DirectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DirectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDirectionSubscription>() => T;
}

export interface UdcEdge {
  node: Udc;
  cursor: String;
}

export interface UdcEdgePromise extends Promise<UdcEdge>, Fragmentable {
  node: <T = UdcPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UdcEdgeSubscription
  extends Promise<AsyncIterator<UdcEdge>>,
    Fragmentable {
  node: <T = UdcSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUdc {
  count: Int;
}

export interface AggregateUdcPromise
  extends Promise<AggregateUdc>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUdcSubscription
  extends Promise<AsyncIterator<AggregateUdc>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TitleSubscriptionPayload {
  mutation: MutationType;
  node: Title;
  updatedFields: String[];
  previousValues: TitlePreviousValues;
}

export interface TitleSubscriptionPayloadPromise
  extends Promise<TitleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TitlePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TitlePreviousValuesPromise>() => T;
}

export interface TitleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TitleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TitleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TitlePreviousValuesSubscription>() => T;
}

export interface UdcConnection {
  pageInfo: PageInfo;
  edges: UdcEdge[];
}

export interface UdcConnectionPromise
  extends Promise<UdcConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UdcEdge>>() => T;
  aggregate: <T = AggregateUdcPromise>() => T;
}

export interface UdcConnectionSubscription
  extends Promise<AsyncIterator<UdcConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UdcEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUdcSubscription>() => T;
}

export interface Author {
  id: ID_Output;
  fullName: String;
}

export interface AuthorPromise extends Promise<Author>, Fragmentable {
  id: () => Promise<ID_Output>;
  fullName: () => Promise<String>;
}

export interface AuthorSubscription
  extends Promise<AsyncIterator<Author>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fullName: () => Promise<AsyncIterator<String>>;
}

export interface AuthorNullablePromise
  extends Promise<Author | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fullName: () => Promise<String>;
}

export interface AggregateTitle {
  count: Int;
}

export interface AggregateTitlePromise
  extends Promise<AggregateTitle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTitleSubscription
  extends Promise<AsyncIterator<AggregateTitle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TitleConnection {
  pageInfo: PageInfo;
  edges: TitleEdge[];
}

export interface TitleConnectionPromise
  extends Promise<TitleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TitleEdge>>() => T;
  aggregate: <T = AggregateTitlePromise>() => T;
}

export interface TitleConnectionSubscription
  extends Promise<AsyncIterator<TitleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TitleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTitleSubscription>() => T;
}

export interface AuthorSubscriptionPayload {
  mutation: MutationType;
  node: Author;
  updatedFields: String[];
  previousValues: AuthorPreviousValues;
}

export interface AuthorSubscriptionPayloadPromise
  extends Promise<AuthorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthorPreviousValuesPromise>() => T;
}

export interface AuthorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthorPreviousValuesSubscription>() => T;
}

export interface SpecializationEdge {
  node: Specialization;
  cursor: String;
}

export interface SpecializationEdgePromise
  extends Promise<SpecializationEdge>,
    Fragmentable {
  node: <T = SpecializationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecializationEdgeSubscription
  extends Promise<AsyncIterator<SpecializationEdge>>,
    Fragmentable {
  node: <T = SpecializationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthorPreviousValues {
  id: ID_Output;
  fullName: String;
}

export interface AuthorPreviousValuesPromise
  extends Promise<AuthorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fullName: () => Promise<String>;
}

export interface AuthorPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fullName: () => Promise<AsyncIterator<String>>;
}

export interface UdcSubscriptionPayload {
  mutation: MutationType;
  node: Udc;
  updatedFields: String[];
  previousValues: UdcPreviousValues;
}

export interface UdcSubscriptionPayloadPromise
  extends Promise<UdcSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UdcPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UdcPreviousValuesPromise>() => T;
}

export interface UdcSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UdcSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UdcSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UdcPreviousValuesSubscription>() => T;
}

export interface TitlePreviousValues {
  id: ID_Output;
  title: String;
}

export interface TitlePreviousValuesPromise
  extends Promise<TitlePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface TitlePreviousValuesSubscription
  extends Promise<AsyncIterator<TitlePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ResourceEdge {
  node: Resource;
  cursor: String;
}

export interface ResourceEdgePromise
  extends Promise<ResourceEdge>,
    Fragmentable {
  node: <T = ResourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResourceEdgeSubscription
  extends Promise<AsyncIterator<ResourceEdge>>,
    Fragmentable {
  node: <T = ResourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContentSubscriptionPayload {
  mutation: MutationType;
  node: Content;
  updatedFields: String[];
  previousValues: ContentPreviousValues;
}

export interface ContentSubscriptionPayloadPromise
  extends Promise<ContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContentPreviousValuesPromise>() => T;
}

export interface ContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContentPreviousValuesSubscription>() => T;
}

export interface AuthorConnection {
  pageInfo: PageInfo;
  edges: AuthorEdge[];
}

export interface AuthorConnectionPromise
  extends Promise<AuthorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthorEdge>>() => T;
  aggregate: <T = AggregateAuthorPromise>() => T;
}

export interface AuthorConnectionSubscription
  extends Promise<AsyncIterator<AuthorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthorSubscription>() => T;
}

export interface ContentPreviousValues {
  id: ID_Output;
  content: String;
}

export interface ContentPreviousValuesPromise
  extends Promise<ContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface ContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface Specialization {
  id: ID_Output;
  specialization: String;
}

export interface SpecializationPromise
  extends Promise<Specialization>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  specialization: () => Promise<String>;
}

export interface SpecializationSubscription
  extends Promise<AsyncIterator<Specialization>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  specialization: () => Promise<AsyncIterator<String>>;
}

export interface SpecializationNullablePromise
  extends Promise<Specialization | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  specialization: () => Promise<String>;
}

export interface Direction {
  id: ID_Output;
  code: String;
}

export interface DirectionPromise extends Promise<Direction>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
}

export interface DirectionSubscription
  extends Promise<AsyncIterator<Direction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface DirectionNullablePromise
  extends Promise<Direction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
}

export interface Resource {
  id: ID_Output;
}

export interface ResourcePromise extends Promise<Resource>, Fragmentable {
  id: () => Promise<ID_Output>;
  author: <T = FragmentableArray<Author>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subAuthor: <T = FragmentableArray<Author>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: <T = TitlePromise>() => T;
  direction: <T = DirectionPromise>() => T;
  profession: <T = ProfessionPromise>() => T;
  specialization: <T = SpecializationPromise>() => T;
  udc: <T = UdcPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface ResourceSubscription
  extends Promise<AsyncIterator<Resource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  author: <T = Promise<AsyncIterator<AuthorSubscription>>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subAuthor: <T = Promise<AsyncIterator<AuthorSubscription>>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: <T = TitleSubscription>() => T;
  direction: <T = DirectionSubscription>() => T;
  profession: <T = ProfessionSubscription>() => T;
  specialization: <T = SpecializationSubscription>() => T;
  udc: <T = UdcSubscription>() => T;
  content: <T = ContentSubscription>() => T;
}

export interface ResourceNullablePromise
  extends Promise<Resource | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  author: <T = FragmentableArray<Author>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subAuthor: <T = FragmentableArray<Author>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: <T = TitlePromise>() => T;
  direction: <T = DirectionPromise>() => T;
  profession: <T = ProfessionPromise>() => T;
  specialization: <T = SpecializationPromise>() => T;
  udc: <T = UdcPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface DirectionSubscriptionPayload {
  mutation: MutationType;
  node: Direction;
  updatedFields: String[];
  previousValues: DirectionPreviousValues;
}

export interface DirectionSubscriptionPayloadPromise
  extends Promise<DirectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DirectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DirectionPreviousValuesPromise>() => T;
}

export interface DirectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DirectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DirectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DirectionPreviousValuesSubscription>() => T;
}

export interface ProfessionEdge {
  node: Profession;
  cursor: String;
}

export interface ProfessionEdgePromise
  extends Promise<ProfessionEdge>,
    Fragmentable {
  node: <T = ProfessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfessionEdgeSubscription
  extends Promise<AsyncIterator<ProfessionEdge>>,
    Fragmentable {
  node: <T = ProfessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DirectionPreviousValues {
  id: ID_Output;
  code: String;
}

export interface DirectionPreviousValuesPromise
  extends Promise<DirectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
}

export interface DirectionPreviousValuesSubscription
  extends Promise<AsyncIterator<DirectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContent {
  count: Int;
}

export interface AggregateContentPromise
  extends Promise<AggregateContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContentSubscription
  extends Promise<AsyncIterator<AggregateContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Content {
  id: ID_Output;
  content: String;
}

export interface ContentPromise extends Promise<Content>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface ContentSubscription
  extends Promise<AsyncIterator<Content>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface ContentNullablePromise
  extends Promise<Content | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface ProfessionSubscriptionPayload {
  mutation: MutationType;
  node: Profession;
  updatedFields: String[];
  previousValues: ProfessionPreviousValues;
}

export interface ProfessionSubscriptionPayloadPromise
  extends Promise<ProfessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfessionPreviousValuesPromise>() => T;
}

export interface ProfessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfessionPreviousValuesSubscription>() => T;
}

export interface AggregateSpecialization {
  count: Int;
}

export interface AggregateSpecializationPromise
  extends Promise<AggregateSpecialization>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecializationSubscription
  extends Promise<AsyncIterator<AggregateSpecialization>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfessionPreviousValues {
  id: ID_Output;
  profession: String;
}

export interface ProfessionPreviousValuesPromise
  extends Promise<ProfessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  profession: () => Promise<String>;
}

export interface ProfessionPreviousValuesSubscription
  extends Promise<AsyncIterator<ProfessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  profession: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResource {
  count: Int;
}

export interface AggregateResourcePromise
  extends Promise<AggregateResource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResourceSubscription
  extends Promise<AsyncIterator<AggregateResource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContentEdge {
  node: Content;
  cursor: String;
}

export interface ContentEdgePromise extends Promise<ContentEdge>, Fragmentable {
  node: <T = ContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContentEdgeSubscription
  extends Promise<AsyncIterator<ContentEdge>>,
    Fragmentable {
  node: <T = ContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Udc {
  id: ID_Output;
  udc: String;
}

export interface UdcPromise extends Promise<Udc>, Fragmentable {
  id: () => Promise<ID_Output>;
  udc: () => Promise<String>;
}

export interface UdcSubscription
  extends Promise<AsyncIterator<Udc>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  udc: () => Promise<AsyncIterator<String>>;
}

export interface UdcNullablePromise extends Promise<Udc | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  udc: () => Promise<String>;
}

export interface ResourceSubscriptionPayload {
  mutation: MutationType;
  node: Resource;
  updatedFields: String[];
  previousValues: ResourcePreviousValues;
}

export interface ResourceSubscriptionPayloadPromise
  extends Promise<ResourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResourcePreviousValuesPromise>() => T;
}

export interface ResourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResourcePreviousValuesSubscription>() => T;
}

export interface AggregateProfession {
  count: Int;
}

export interface AggregateProfessionPromise
  extends Promise<AggregateProfession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfessionSubscription
  extends Promise<AsyncIterator<AggregateProfession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ResourcePreviousValues {
  id: ID_Output;
}

export interface ResourcePreviousValuesPromise
  extends Promise<ResourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ResourcePreviousValuesSubscription
  extends Promise<AsyncIterator<ResourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Profession {
  id: ID_Output;
  profession: String;
}

export interface ProfessionPromise extends Promise<Profession>, Fragmentable {
  id: () => Promise<ID_Output>;
  profession: () => Promise<String>;
}

export interface ProfessionSubscription
  extends Promise<AsyncIterator<Profession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  profession: () => Promise<AsyncIterator<String>>;
}

export interface ProfessionNullablePromise
  extends Promise<Profession | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  profession: () => Promise<String>;
}

export interface SpecializationConnection {
  pageInfo: PageInfo;
  edges: SpecializationEdge[];
}

export interface SpecializationConnectionPromise
  extends Promise<SpecializationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecializationEdge>>() => T;
  aggregate: <T = AggregateSpecializationPromise>() => T;
}

export interface SpecializationConnectionSubscription
  extends Promise<AsyncIterator<SpecializationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecializationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecializationSubscription>() => T;
}

export interface AuthorEdge {
  node: Author;
  cursor: String;
}

export interface AuthorEdgePromise extends Promise<AuthorEdge>, Fragmentable {
  node: <T = AuthorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthorEdgeSubscription
  extends Promise<AsyncIterator<AuthorEdge>>,
    Fragmentable {
  node: <T = AuthorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SpecializationPreviousValues {
  id: ID_Output;
  specialization: String;
}

export interface SpecializationPreviousValuesPromise
  extends Promise<SpecializationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  specialization: () => Promise<String>;
}

export interface SpecializationPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecializationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  specialization: () => Promise<AsyncIterator<String>>;
}

export interface SpecializationSubscriptionPayload {
  mutation: MutationType;
  node: Specialization;
  updatedFields: String[];
  previousValues: SpecializationPreviousValues;
}

export interface SpecializationSubscriptionPayloadPromise
  extends Promise<SpecializationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecializationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecializationPreviousValuesPromise>() => T;
}

export interface SpecializationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecializationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecializationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecializationPreviousValuesSubscription>() => T;
}

export interface ContentConnection {
  pageInfo: PageInfo;
  edges: ContentEdge[];
}

export interface ContentConnectionPromise
  extends Promise<ContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContentEdge>>() => T;
  aggregate: <T = AggregateContentPromise>() => T;
}

export interface ContentConnectionSubscription
  extends Promise<AsyncIterator<ContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContentSubscription>() => T;
}

export interface ResourceConnection {
  pageInfo: PageInfo;
  edges: ResourceEdge[];
}

export interface ResourceConnectionPromise
  extends Promise<ResourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResourceEdge>>() => T;
  aggregate: <T = AggregateResourcePromise>() => T;
}

export interface ResourceConnectionSubscription
  extends Promise<AsyncIterator<ResourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResourceSubscription>() => T;
}

export interface TitleEdge {
  node: Title;
  cursor: String;
}

export interface TitleEdgePromise extends Promise<TitleEdge>, Fragmentable {
  node: <T = TitlePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TitleEdgeSubscription
  extends Promise<AsyncIterator<TitleEdge>>,
    Fragmentable {
  node: <T = TitleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProfessionConnection {
  pageInfo: PageInfo;
  edges: ProfessionEdge[];
}

export interface ProfessionConnectionPromise
  extends Promise<ProfessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfessionEdge>>() => T;
  aggregate: <T = AggregateProfessionPromise>() => T;
}

export interface ProfessionConnectionSubscription
  extends Promise<AsyncIterator<ProfessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfessionSubscription>() => T;
}

export interface Title {
  id: ID_Output;
  title: String;
}

export interface TitlePromise extends Promise<Title>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface TitleSubscription
  extends Promise<AsyncIterator<Title>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface TitleNullablePromise
  extends Promise<Title | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Resource",
    embedded: false
  },
  {
    name: "Author",
    embedded: false
  },
  {
    name: "Title",
    embedded: false
  },
  {
    name: "Direction",
    embedded: false
  },
  {
    name: "Profession",
    embedded: false
  },
  {
    name: "Specialization",
    embedded: false
  },
  {
    name: "Udc",
    embedded: false
  },
  {
    name: "Content",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
